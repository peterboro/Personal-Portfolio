/*! @license ScrollReveal v4.0.9

	Copyright 2021 Fisssion LLC.

	Licensed under the GNU General Public License 3.0 for
	compatible open source projects and non-commercial use.

	For commercial sites, themes, projects, and applications,
	keep your source code private/proprietary by purchasing
	a commercial license from https://scrollrevealjs.org/
*/
const ScrollReveal = (function () {
  const r = {
    delay: 0,
    distance: '0',
    duration: 600,
    easing: 'cubic-bezier(0.5, 0, 0, 1)',
    interval: 0,
    opacity: 0,
    origin: 'bottom',
    rotate: { x: 0, y: 0, z: 0 },
    scale: 1,
    cleanup: !1,
    container: document.documentElement,
    desktop: !0,
    mobile: !0,
    reset: !1,
    useDelay: 'always',
    viewFactor: 0,
    viewOffset: {
      top: 0, right: 0, bottom: 0, left: 0,
    },
    afterReset() {},
    afterReveal() {},
    beforeReset() {},
    beforeReveal() {},
  }; const n = {
    success() { document.documentElement.classList.add('sr'), document.body ? document.body.style.height = '100%' : document.addEventListener('DOMContentLoaded', () => { document.body.style.height = '100%'; }); },
    failure() {
      return document.documentElement.classList.remove('sr'), {
        clean() {}, destroy() {}, reveal() {}, sync() {}, get noop() { return !0; },
      };
    },
  }; function o(e) { return typeof window.Node === 'object' ? e instanceof window.Node : e !== null && typeof e === 'object' && typeof e.nodeType === 'number' && typeof e.nodeName === 'string'; } function u(e, t) { if (void 0 === t && (t = document), e instanceof Array) return e.filter(o); if (o(e)) return [e]; if (n = e, i = Object.prototype.toString.call(n), typeof window.NodeList === 'object' ? n instanceof window.NodeList : n !== null && typeof n === 'object' && typeof n.length === 'number' && /^\[object (HTMLCollection|NodeList|Object)\]$/.test(i) && (n.length === 0 || o(n[0]))) return Array.prototype.slice.call(e); let n; let i; if (typeof e === 'string') try { const r = t.querySelectorAll(e); return Array.prototype.slice.call(r); } catch (e) { return []; } return []; } function s(e) { return e !== null && e instanceof Object && (e.constructor === Object || Object.prototype.toString.call(e) === '[object Object]'); } function f(n, i) { if (s(n)) return Object.keys(n).forEach((e) => i(n[e], e, n)); if (n instanceof Array) return n.forEach((e, t) => i(e, t, n)); throw new TypeError('Expected either an array or object literal.'); } function h(e) { for (var t = [], n = arguments.length - 1; n-- > 0;)t[n] = arguments[n + 1]; if (this.constructor.debug && console) { let i = `%cScrollReveal: ${e}`; t.forEach((e) => i += `\n â€” ${e}`), console.log(i, 'color: #ea654b;'); } } function t() { const n = this; const i = { active: [], stale: [] }; const t = { active: [], stale: [] }; const r = { active: [], stale: [] }; try { f(u('[data-sr-id]'), (e) => { const t = parseInt(e.getAttribute('data-sr-id')); i.active.push(t); }); } catch (e) { throw e; }f(this.store.elements, (e) => { i.active.indexOf(e.id) === -1 && i.stale.push(e.id); }), f(i.stale, (e) => delete n.store.elements[e]), f(this.store.elements, (e) => { r.active.indexOf(e.containerId) === -1 && r.active.push(e.containerId), e.hasOwnProperty('sequence') && t.active.indexOf(e.sequence.id) === -1 && t.active.push(e.sequence.id); }), f(this.store.containers, (e) => { r.active.indexOf(e.id) === -1 && r.stale.push(e.id); }), f(r.stale, (e) => { const t = n.store.containers[e].node; t.removeEventListener('scroll', n.delegate), t.removeEventListener('resize', n.delegate), delete n.store.containers[e]; }), f(this.store.sequences, (e) => { t.active.indexOf(e.id) === -1 && t.stale.push(e.id); }), f(t.stale, (e) => delete n.store.sequences[e]); } function N(e) { if (e.constructor !== Array) throw new TypeError('Expected array.'); if (e.length === 16) return e; if (e.length !== 6) throw new RangeError('Expected array with either 6 or 16 values.'); const t = z(); return t[0] = e[0], t[1] = e[1], t[4] = e[2], t[5] = e[3], t[12] = e[4], t[13] = e[5], t; } function z() { for (var e = [], t = 0; t < 16; t++)t % 5 == 0 ? e.push(1) : e.push(0); return e; } function F(e, t) { for (var n = N(e), i = N(t), r = [], o = 0; o < 4; o++) for (let s = [n[o], n[o + 4], n[o + 8], n[o + 12]], a = 0; a < 4; a++) { const c = 4 * a; const l = [i[c], i[c + 1], i[c + 2], i[c + 3]]; const d = s[0] * l[0] + s[1] * l[1] + s[2] * l[2] + s[3] * l[3]; r[o + c] = d; } return r; } function D(e, t) { const n = z(); return n[0] = e, n[5] = typeof t === 'number' ? t : e, n; } const S = (function () { let n = {}; const i = document.documentElement.style; function e(e, t) { if (void 0 === t && (t = i), e && typeof e === 'string') { if (n[e]) return n[e]; if (typeof t[e] === 'string') return n[e] = e; if (typeof t[`-webkit-${e}`] === 'string') return n[e] = `-webkit-${e}`; throw new RangeError(`Unable to find "${e}" style property.`); } throw new TypeError('Expected a string.'); } return e.clearCache = function () { return n = {}; }, e; }()); function p(e) {
    const t = window.getComputedStyle(e.node); const n = t.position; const i = e.config; const r = {}; const o = (e.node.getAttribute('style') || '').match(/[\w-]+\s*:\s*[^;]+\s*/gi) || []; r.computed = o ? `${o.map((e) => e.trim()).join('; ')};` : '', r.generated = o.some((e) => e.match(/visibility\s?:\s?visible/i)) ? r.computed : `${o.concat(['visibility: visible']).map((e) => e.trim()).join('; ')};`; let s; let a; let c; let l; let d; let u; let f; let h; let p; let m; let y; let v; let g; const b = parseFloat(t.opacity); const w = isNaN(parseFloat(i.opacity)) ? parseFloat(t.opacity) : parseFloat(i.opacity); const E = { computed: b !== w ? `opacity: ${b};` : '', generated: b !== w ? `opacity: ${w};` : '' }; const j = []; if (parseFloat(i.distance)) { const T = i.origin === 'top' || i.origin === 'bottom' ? 'Y' : 'X'; let k = i.distance; i.origin !== 'top' && i.origin !== 'left' || (k = /^-/.test(k) ? k.substr(1) : `-${k}`); const O = k.match(/(^-?\d+\.?\d?)|(em$|px$|%$)/g); const x = O[0]; switch (O[1]) { case 'em': k = parseInt(t.fontSize) * x; break; case 'px': k = x; break; case '%': k = T === 'Y' ? e.node.getBoundingClientRect().height * x / 100 : e.node.getBoundingClientRect().width * x / 100; break; default: throw new RangeError('Unrecognized or missing distance unit.'); }T === 'Y' ? j.push((c = k, (l = z())[13] = c, l)) : j.push((s = k, (a = z())[12] = s, a)); }i.rotate.x && j.push((d = i.rotate.x, u = Math.PI / 180 * d, (f = z())[5] = f[10] = Math.cos(u), f[6] = f[9] = Math.sin(u), f[9] *= -1, f)), i.rotate.y && j.push((h = i.rotate.y, p = Math.PI / 180 * h, (m = z())[0] = m[10] = Math.cos(p), m[2] = m[8] = Math.sin(p), m[2] *= -1, m)), i.rotate.z && j.push((y = i.rotate.z, v = Math.PI / 180 * y, (g = z())[0] = g[5] = Math.cos(v), g[1] = g[4] = Math.sin(v), g[4] *= -1, g)), i.scale !== 1 && (i.scale === 0 ? j.push(D(2e-4)) : j.push(D(i.scale))); const R = {}; if (j.length) { R.property = S('transform'), R.computed = { raw: t[R.property], matrix: (function (e) { if (typeof e === 'string') { const t = e.match(/matrix(3d)?\(([^)]+)\)/); if (t) return N(t[2].split(', ').map(parseFloat)); } return z(); }(t[R.property])) }, j.unshift(R.computed.matrix); const q = j.reduce(F); R.generated = { initial: `${R.property}: matrix3d(${q.join(', ')});`, final: `${R.property}: matrix3d(${R.computed.matrix.join(', ')});` }; } else R.generated = { initial: '', final: '' }; const A = {}; if (E.generated || R.generated.initial) { A.property = S('transition'), A.computed = t[A.property], A.fragments = []; const P = i.delay; const L = i.duration; const M = i.easing; E.generated && A.fragments.push({ delayed: `opacity ${L / 1e3}s ${M} ${P / 1e3}s`, instant: `opacity ${L / 1e3}s ${M} 0s` }), R.generated.initial && A.fragments.push({ delayed: `${R.property} ${L / 1e3}s ${M} ${P / 1e3}s`, instant: `${R.property} ${L / 1e3}s ${M} 0s` }), A.computed && !A.computed.match(/all 0s|none 0s/) && A.fragments.unshift({ delayed: A.computed, instant: A.computed }); const I = A.fragments.reduce((e, t, n) => (e.delayed += n === 0 ? t.delayed : `, ${t.delayed}`, e.instant += n === 0 ? t.instant : `, ${t.instant}`, e), { delayed: '', instant: '' }); A.generated = { delayed: `${A.property}: ${I.delayed};`, instant: `${A.property}: ${I.instant};` }; } else A.generated = { delayed: '', instant: '' }; return {
      inline: r, opacity: E, position: n, transform: R, transition: A,
    };
  } function m(r, e) { e.split(';').forEach((e) => { const t = e.split(':'); const n = t[0]; const i = t.slice(1); n && i && (r.style[n.trim()] = i.join(':')); }); } function y(e) { let i; const r = this; try { f(u(e), (e) => { const t = e.getAttribute('data-sr-id'); if (t !== null) { i = !0; const n = r.store.elements[t]; n.callbackTimer && window.clearTimeout(n.callbackTimer.clock), m(n.node, n.styles.inline.generated), e.removeAttribute('data-sr-id'), delete r.store.elements[t]; } }); } catch (e) { return h.call(this, 'Clean failed.', e.message); } if (i) try { t.call(this); } catch (e) { return h.call(this, 'Clean failed.', e.message); } } function v(n) { for (var e = [], t = arguments.length - 1; t-- > 0;)e[t] = arguments[t + 1]; if (s(n)) return f(e, (e) => { f(e, (e, t) => { s(e) ? (n[t] && s(n[t]) || (n[t] = {}), v(n[t], e)) : n[t] = e; }); }), n; throw new TypeError('Target must be an object literal.'); } function g(e) { return void 0 === e && (e = navigator.userAgent), /Android|iPhone|iPad|iPod/i.test(e); } let e; const b = (e = 0, function () { return e++; }); function w() { const n = this; t.call(this), f(this.store.elements, (e) => { const t = [e.styles.inline.generated]; e.visible ? (t.push(e.styles.opacity.computed), t.push(e.styles.transform.generated.final), e.revealed = !0) : (t.push(e.styles.opacity.generated), t.push(e.styles.transform.generated.initial), e.revealed = !1), m(e.node, t.filter((e) => e !== '').join(' ')); }), f(this.store.containers, (e) => { const t = e.node === document.documentElement ? window : e.node; t.addEventListener('scroll', n.delegate), t.addEventListener('resize', n.delegate); }), this.delegate(), this.initTimeout = null; } function c(e, t) { void 0 === t && (t = {}); const n = t.pristine || this.pristine; const i = e.config.useDelay === 'always' || e.config.useDelay === 'onload' && n || e.config.useDelay === 'once' && !e.seen; const r = e.visible && !e.revealed; const o = !e.visible && e.revealed && e.config.reset; return t.reveal || r ? function (e, t) { const n = [e.styles.inline.generated, e.styles.opacity.computed, e.styles.transform.generated.final]; t ? n.push(e.styles.transition.generated.delayed) : n.push(e.styles.transition.generated.instant); e.revealed = e.seen = !0, m(e.node, n.filter((e) => e !== '').join(' ')), a.call(this, e, t); }.call(this, e, i) : t.reset || o ? function (e) { const t = [e.styles.inline.generated, e.styles.opacity.generated, e.styles.transform.generated.initial, e.styles.transition.generated.instant]; e.revealed = !1, m(e.node, t.filter((e) => e !== '').join(' ')), a.call(this, e); }.call(this, e) : void 0; } function a(e, t) { const n = this; const i = t ? e.config.duration + e.config.delay : e.config.duration; const r = e.revealed ? e.config.beforeReveal : e.config.beforeReset; const o = e.revealed ? e.config.afterReveal : e.config.afterReset; let s = 0; e.callbackTimer && (s = Date.now() - e.callbackTimer.start, window.clearTimeout(e.callbackTimer.clock)), r(e.node), e.callbackTimer = { start: Date.now(), clock: window.setTimeout(() => { o(e.node), e.callbackTimer = null, e.revealed && !e.config.reset && e.config.cleanup && y.call(n, e.node); }, i - s) }; } function l(e, t) { if (void 0 === t && (t = this.pristine), !e.visible && e.revealed && e.config.reset) return c.call(this, e, { reset: !0 }); const n = this.store.sequences[e.sequence.id]; const i = e.sequence.index; if (n) { const r = new d(n, 'visible', this.store); const o = new d(n, 'revealed', this.store); if (n.models = { visible: r, revealed: o }, !o.body.length) { const s = n.members[r.body[0]]; const a = this.store.elements[s]; if (a) return j.call(this, n, r.body[0], -1, t), j.call(this, n, r.body[0], 1, t), c.call(this, a, { reveal: !0, pristine: t }); } if (!n.blocked.head && i === [].concat(o.head).pop() && i >= [].concat(r.body).shift()) return j.call(this, n, i, -1, t), c.call(this, e, { reveal: !0, pristine: t }); if (!n.blocked.foot && i === [].concat(o.foot).shift() && i <= [].concat(r.body).pop()) return j.call(this, n, i, 1, t), c.call(this, e, { reveal: !0, pristine: t }); } } function E(e) { const t = Math.abs(e); if (isNaN(t)) throw new RangeError('Invalid sequence interval.'); this.id = b(), this.interval = Math.max(t, 16), this.members = [], this.models = {}, this.blocked = { head: !1, foot: !1 }; } function d(e, i, r) { const o = this; this.head = [], this.body = [], this.foot = [], f(e.members, (e, t) => { const n = r.elements[e]; n && n[i] && o.body.push(t); }), this.body.length && f(e.members, (e, t) => { const n = r.elements[e]; n && !n[i] && (t < o.body[0] ? o.head.push(t) : o.foot.push(t)); }); } function j(e, t, n, i) { const r = this; const o = ['head', null, 'foot'][1 + n]; const s = e.members[t + n]; const a = this.store.elements[s]; e.blocked[o] = !0, setTimeout(() => { e.blocked[o] = !1, a && l.call(r, a, i); }, e.interval); } function i(e, a, t) { const c = this; void 0 === a && (a = {}), void 0 === t && (t = !1); let l; const d = []; const n = a.interval || r.interval; try { n && (l = new E(n)); const i = u(e); if (!i.length) throw new Error('Invalid reveal target.'); f(i.reduce((e, t) => { const n = {}; const i = t.getAttribute('data-sr-id'); i ? (v(n, c.store.elements[i]), m(n.node, n.styles.inline.computed)) : (n.id = b(), n.node = t, n.seen = !1, n.revealed = !1, n.visible = !1); const r = v({}, n.config || c.defaults, a); if (!r.mobile && g() || !r.desktop && !g()) return i && y.call(c, n), e; let o; const s = u(r.container)[0]; if (!s) throw new Error('Invalid container.'); return s.contains(t) && ((o = (function (t) { const e = []; let n = arguments.length - 1; for (;n-- > 0;)e[n] = arguments[n + 1]; let i = null; return f(e, (e) => { f(e, (e) => { i === null && e.node === t && (i = e.id); }); }), i; }(s, d, c.store.containers))) === null && (o = b(), d.push({ id: o, node: s })), n.config = r, n.containerId = o, n.styles = p(n), l && (n.sequence = { id: l.id, index: l.members.length }, l.members.push(n.id)), e.push(n)), e; }, []), (e) => { (c.store.elements[e.id] = e).node.setAttribute('data-sr-id', e.id); }); } catch (e) { return h.call(this, 'Reveal failed.', e.message); }f(d, (e) => { c.store.containers[e.id] = { id: e.id, node: e.node }; }), l && (this.store.sequences[l.id] = l), !0 !== t && (this.store.history.push({ target: e, options: a }), this.initTimeout && window.clearTimeout(this.initTimeout), this.initTimeout = window.setTimeout(w.bind(this), 0)); } let T; const k = Math.sign || function (e) { return (e > 0) - (e < 0) || +e; }; var O = (T = Date.now(), function (e) { const t = Date.now(); t - T > 16 ? e(T = t) : setTimeout(() => O(e), 0); }); const x = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || O; function R(e, t) {
    for (var n = t ? e.node.clientHeight : e.node.offsetHeight, i = t ? e.node.clientWidth : e.node.offsetWidth, r = 0, o = 0, s = e.node; isNaN(s.offsetTop) || (r += s.offsetTop), isNaN(s.offsetLeft) || (o += s.offsetLeft), s = s.offsetParent;);return {
      bounds: {
        top: r, right: o + i, bottom: r + n, left: o,
      },
      height: n,
      width: i,
    };
  } function q(e, t) { const i = this; void 0 === e && (e = { type: 'init' }), void 0 === t && (t = this.store.elements), x(() => { const n = e.type === 'init' || e.type === 'resize'; f(i.store.containers, (e) => { n && (e.geometry = R.call(i, e, !0)); const t = function (e) { let t; let n; return n = e.node === document.documentElement ? (t = window.pageYOffset, window.pageXOffset) : (t = e.node.scrollTop, e.node.scrollLeft), { top: t, left: n }; }.call(i, e); e.scroll && (e.direction = { x: k(t.left - e.scroll.left), y: k(t.top - e.scroll.top) }), e.scroll = t; }), f(t, (e) => { (n || void 0 === e.geometry) && (e.geometry = R.call(i, e)), e.visible = function (e) { void 0 === e && (e = {}); const t = this.store.containers[e.containerId]; if (t) { const n = Math.max(0, Math.min(1, e.config.viewFactor)); const i = e.config.viewOffset; const r = e.geometry.bounds.top + e.geometry.height * n; const o = e.geometry.bounds.right - e.geometry.width * n; const s = e.geometry.bounds.bottom - e.geometry.height * n; const a = e.geometry.bounds.left + e.geometry.width * n; const c = t.geometry.bounds.top + t.scroll.top + i.top; const l = t.geometry.bounds.right + t.scroll.left - i.right; const d = t.geometry.bounds.bottom + t.scroll.top - i.bottom; const u = t.geometry.bounds.left + t.scroll.left + i.left; return r < d && u < o && c < s && a < l || e.styles.position === 'fixed'; } }.call(i, e); }), f(t, (e) => { e.sequence ? l.call(i, e) : c.call(i, e); }), i.pristine = !1; }); } let A; let P; let L; let M; let I; let C; let W; let Y; const $ = '4.0.9'; function H(e) {
    let t; if (void 0 === e && (e = {}), void 0 === this || Object.getPrototypeOf(this) !== H.prototype) return new H(e); if (!H.isSupported()) return h.call(this, 'Instantiation failed.', 'This browser is not supported.'), n.failure(); try { t = v({}, C || r, e); } catch (e) { return h.call(this, 'Invalid configuration.', e.message), n.failure(); } try { if (!u(t.container)[0]) throw new Error('Invalid container.'); } catch (e) { return h.call(this, e.message), n.failure(); } return !(C = t).mobile && g() || !C.desktop && !g() ? (h.call(this, 'This device is disabled.', `desktop: ${C.desktop}`, `mobile: ${C.mobile}`), n.failure()) : (n.success(), this.store = {
      containers: {}, elements: {}, history: [], sequences: {},
    }, this.pristine = !0, A = A || q.bind(this), P = P || function () {
      const n = this; f(this.store.elements, (e) => { m(e.node, e.styles.inline.generated), e.node.removeAttribute('data-sr-id'); }), f(this.store.containers, (e) => { const t = e.node === document.documentElement ? window : e.node; t.removeEventListener('scroll', n.delegate), t.removeEventListener('resize', n.delegate); }), this.store = {
        containers: {}, elements: {}, history: [], sequences: {},
      };
    }.bind(this), L = L || i.bind(this), M = M || y.bind(this), I = I || function () { const t = this; f(this.store.history, (e) => { i.call(t, e.target, e.options, !0); }), w.call(this); }.bind(this), Object.defineProperty(this, 'delegate', { get() { return A; } }), Object.defineProperty(this, 'destroy', { get() { return P; } }), Object.defineProperty(this, 'reveal', { get() { return L; } }), Object.defineProperty(this, 'clean', { get() { return M; } }), Object.defineProperty(this, 'sync', { get() { return I; } }), Object.defineProperty(this, 'defaults', { get() { return C; } }), Object.defineProperty(this, 'version', { get() { return $; } }), Object.defineProperty(this, 'noop', { get() { return !1; } }), Y || (Y = this));
  } return H.isSupported = function () { return ('transform' in (t = document.documentElement.style) || 'WebkitTransform' in t) && ('transition' in (e = document.documentElement.style) || 'WebkitTransition' in e); let e; let t; }, Object.defineProperty(H, 'debug', { get() { return W || !1; }, set(e) { return W = typeof e === 'boolean' ? e : W; } }), H(), H;
}());
